# Project Analysis: Your Social Media

This document provides a technical analysis of the "Your Social Media" application, detailing its architecture, functionalities, and overall objective. 

## 1. Objective

The "Your Social Media" application is a web-based platform designed to assist YouTube content creators in optimizing their video content for improved discoverability, engagement, and overall SEO performance. Its primary focus is on providing tools for:

*   **Automated Transcription of Uploaded Media:** Processing user-uploaded audio or video files to generate accurate text transcriptions using the Groq Whisper API.
*   **AI-Powered Content Generation:** Leveraging artificial intelligence to generate various YouTube-specific text assets based on the transcriptions obtained from uploaded files. This includes:
    *   **Video Titles:** Offering a diverse range of styles (e.g., viral, SEO-optimized, clickbait, descriptive).
    *   **Video Descriptions:** Providing multiple formats (e.g., analytical, promotional, storytelling).
    *   **Video Chapters:** Automatically identifying and timestamping key segments.
*   **Complete Package Generation:** A unified interface that allows users to generate all content types at once with customizable options:
    *   **Content Selection:** Users can choose which content types to generate (titles, description, chapters, or any combination).
    *   **Output Formatting:** Choice between plain text or Markdown formatting.
    *   **Description Customization:** Selection of description style (analytical, curiosity-driven, hashtag-focused, etc.).
    *   **Chapter Configuration:** Adjustable number of chapters via slider (3-20 chapters).

## 2. Key Features

*   **Transcription of Uploaded Media:**
    *   Allows users to upload audio (MP3, WAV, etc.) and video (MP4, etc.) files for transcription.
    *   Utilizes Groq Whisper API for highly accurate and fast audio-to-text conversion.
    *   Includes automatic segmentation for large files and provides precise timestamps.
*   **Intelligent Content Generation (Based on Uploaded Media Transcriptions):**
    *   Employs Google Generative AI for creating titles, descriptions, and chapters from the transcriptions of uploaded files.
    *   **User-Configurable Generation Options:**
        *   **Output Formatting:** User can choose between "Texto simples (sem formataÃ§Ã£o)" (Plain Text) or "Markdown (com formataÃ§Ã£o)" (Markdown).
        *   **Content Selection:** User can select which content types to generate (Gerar TÃ­tulos, Gerar DescriÃ§Ã£o, Gerar CapÃ­tulos).
        *   **Description Type:** If description generation is selected, user can choose a specific style from a dropdown (e.g., "analÃ­tica", "curiosidade", "hashtags", "tÃ³picos", "gatilhos", "engajamento").
        *   **Number of Chapters:** If chapter generation is selected, user can specify the desired number of chapters using a slider (e.g., between 3 and 20, default 6).
        *   **Title Types:** Multiple title styles can be selected including impactante, analÃ­tico, agressivo, nicho, engajamento, curiosidade, SEO clÃ¡ssico, storytelling, shorts, and live/podcast formats.
    *   Offers a rich selection of content styles (these are likely defaults or internal types that the user choices map to):
        *   **10 Title Types:** Viral, SEO, Educativo, Questionador, NumÃ©rico, Urgente, BenefÃ­cio, Problema/SoluÃ§Ã£o, Comparativo, Tutorial (the UI suggests a general "Gerar TÃ­tulos" checkbox, the specific types might be generated by default or based on premium features if applicable).
        *   **6 Description Types:** (as listed in the user-selectable dropdown) AnalÃ­tica, Curiosidade, Hashtags, TÃ³picos, Gatilhos, Engajamento.
    *   Generates automatic video chapters with descriptive titles and timestamps (configurable number, default 6).
*   **Multilingual Capabilities:**
    *   Automatically detects the language of the input content.
    *   Supports content generation in multiple languages: Portuguese (PT), English (EN), Spanish (ES), French (FR), Italian (IT), German (DE).
*   **User Management System:**
    *   Secure JWT (JSON Web Token) based authentication.
    *   Differentiated user plans (Free/Premium) with varying feature access and usage limits (e.g., number of transcriptions, file size limits).
    *   Provides users with a history of their transcriptions and generated content.
*   **Asynchronous Task Processing:**
    *   Utilizes Celery with Redis as a message broker to handle computationally intensive and time-consuming tasks (like transcription and AI content generation) in the background, ensuring a responsive user interface.
*   **API-Driven Architecture:**
    *   The backend exposes a RESTful API built with Django REST Framework, allowing for clear separation between frontend and backend logic.

## 3. Technical Architecture

The application follows a modern, decoupled architecture:

*   **Backend:**
    *   **Framework:** Django (version 4.2 likely, based on migration files) & Django REST Framework
    *   **Database:** PostgreSQL (for persistent data storage)
    *   **Caching & Message Broker:** Redis (for Celery task queuing and potentially caching)
    *   **Asynchronous Task Queue:** Celery (for background job processing)
    *   **WSGI Server:** Gunicorn (for running the Django application in production)
    *   **Programming Language:** Python 3.12
*   **Frontend:**
    *   **Framework:** Vue.js 3
    *   **Language:** TypeScript (for static typing and improved code quality)
    *   **Styling:** Tailwind CSS (a utility-first CSS framework)
    *   **State Management:** Pinia (the official state management library for Vue.js)
    *   **Build Tool:** Vite (for fast development and optimized production builds)
    *   **Web Server:** Nginx (typically used to serve the static frontend files and proxy API requests in production)
*   **Artificial Intelligence APIs:**
    *   **Google Generative AI:** Used for the core content generation tasks (titles, descriptions, chapters).
    *   **Groq Whisper API:** Used for accurate and fast audio transcription.
*   **Deployment & Orchestration:**
    *   **Containerization:** Docker (backend, frontend, database, and other services are likely containerized)
    *   **Orchestration/Deployment Platform:** Coolify (as indicated in `README.md` and `coolify-simple.yml`) 

## 4. Backend Modules (Django Apps)

The backend is modular, with distinct Django applications responsible for specific functionalities:

*   **`apps.users`:**
    *   Handles user authentication (likely using JWT, as suggested by `rest_framework_simplejwt` in the Celery worker log and common Django practice).
    *   Manages user profiles, including plans (Free/Premium) and potentially usage quotas.
    *   The `settings.AUTH_USER_MODEL` is referenced in other models, indicating a custom user model or integration with Django's default user model.
*   **`apps.transcriptions`:**
    *   Manages the lifecycle of transcriptions primarily from user-uploaded audio/video files:
        *   Accepting audio/video file uploads.
        *   Storing information about the source (`source_type` set to 'audio_upload' or 'video_upload', `original_filename`).
        *   Handling file uploads (`audio_file`, `video_file` fields in `Transcription` model).
        *   Tracking transcription status (`pending`, `processing`, `completed`, `failed`).
        *   Storing detected language, model used (Whisper via Groq API), and the final transcription text.
        *   Managing metadata like duration, file size, and processing time.
        *   Storing transcription segments (`TranscriptionSegment` model) for large files, including start/end times and confidence scores.
    *   Contains a Celery task (`process_audio_transcription` in `tasks.py`) to offload the transcription of uploaded files.
    *   Provides serializers (`TranscriptionCreateSerializer`, `TranscriptionDetailSerializer`, `TranscriptionListSerializer`) for API interactions related to uploaded media.
    *   Includes `AudioTranscriptionService` and parts of `TranscriptionService` in `services.py` to encapsulate the logic for handling uploaded files and transcribing them via Groq Whisper API.
*   **`apps.content_generation`:**
    *   Orchestrates the generation of YouTube content (titles, descriptions, chapters) based on completed transcriptions derived from uploaded files.
    *   The `ContentGeneration` model links to a `Transcription` and a `User`.
    *   Stores request details: 
        *   `content_type` (can be a combination or individual selections based on UI checkboxes: titles, description, chapters, or 'complete' if all are selected).
        *   `use_markdown` (BooleanField): Reflects the user's choice of "Texto simples" vs "Markdown".
        *   `title_types` (JSONField, nullable): While the UI shows a single "Gerar TÃ­tulos" checkbox, this field could store specific types if more granular control is implemented or for premium features. If only a general request, it might store a default set or be less relevant if title generation is a monolithic block.
        *   `description_type` (CharField, nullable): Stores the user's choice from the "Tipo de descriÃ§Ã£o" dropdown (e.g., 'analÃ­tica', 'curiosidade').
        *   `max_chapters` (IntegerField, nullable): Stores the user's choice from the "NÃºmero de capÃ­tulos" slider.
    *   Tracks the status of content generation requests (`pending`, `processing`, `completed`, `failed`).
    *   Stores the `language_detected` (likely from the associated transcription) and the `generated_content` itself, or references to generated items.
    *   Models `GeneratedTitle` and `GeneratedChapter` store the individual pieces of generated content, linked back to a `ContentGeneration` instance.
    *   Contains Celery tasks (`process_content_generation` in `tasks.py`) for asynchronous AI content generation.
    *   Defines serializers (`ContentGenerationCreateSerializer`, `ContentGenerationDetailSerializer`, etc.) for handling API requests and responses.
    *   The core AI interaction logic resides in `ContentGenerationService` (`services.py`), which communicates with Google Generative AI.
    *   Defines various API views (`ContentGenerationCreateView`, `ContentGenerationListView`, etc.) for CRUD operations and other actions like retrying failed generations or fetching stats.

## 5. Frontend Structure (Vue.js)

The frontend is a Single Page Application (SPA) built with Vue.js 3 and TypeScript. Key directories within `frontend/src/` include:

*   **`components/`**: Contains reusable Vue components used across different parts of the application (e.g., buttons, modals, specific UI sections like `PendingTranscriptionsManager.vue`).
*   **`views/`**: Holds page-level components that correspond to different routes/screens of the application. Based on file names, these likely include:
    *   `HomeView.vue`: The main landing page.
    *   `UploadView.vue`: Interface for uploading audio/video files.
    *   `TranscriptionView.vue` / `TranscriptionManagementView.vue`: For viewing and managing transcriptions.
    *   `ContentGenerationView.vue`: Interface for initiating and viewing AI-generated content.
*   **`router/` (`index.js`):** Configures client-side routing, mapping URLs to specific Vue components (views). This enables navigation within the SPA without full page reloads.
*   **`services/` (`api.js`):** Encapsulates logic for making HTTP requests to the backend API. This typically includes functions for authentication, fetching data, and submitting data related to transcriptions and content generation.
*   **`stores/` (`auth.js`):** Manages global application state using Pinia. The `auth.js` file specifically handles authentication state (e.g., user tokens, profile information, login/logout actions, registration, fetching user stats).
*   **`App.vue`**: The root Vue component that typically sets up the main layout and global elements.
*   **`main.js`**: The entry point of the Vue application, where the Vue instance is created, plugins (like the router, Pinia, and toast notifications) are initialized, and the root component (`App.vue`) is mounted.
*   **`style.css`**: Contains global CSS styles and potentially utility classes, complementing Tailwind CSS. 

## 6. Data Models and Database

The application uses PostgreSQL as its relational database. The core data models, defined in the Django apps, are as follows:

### `apps.transcriptions.models`

*   **`Transcription`**: The central model for storing all information related to a single transcription task.
    *   `id` (UUID, Primary Key): Unique identifier for the transcription.
    *   `user` (ForeignKey to `settings.AUTH_USER_MODEL`, nullable): Links to the user who initiated the transcription.
    *   `source_type` (CharField): Indicates the origin of the media (e.g., 'youtube', 'audio_upload', 'video_upload').
    *   `source_url` (URLField, nullable): URL for YouTube videos.
    *   `original_filename` (CharField, nullable): Name of the uploaded file.
    *   `audio_file` (FileField, nullable): Stores the uploaded audio file.
    *   `video_file` (FileField, nullable): Stores the uploaded video file.
    *   `status` (CharField): Current status of the transcription (pending, processing, completed, failed).
    *   `model_used` (CharField, nullable): The specific Whisper model variant used.
    *   `language_detected` (CharField, nullable): Detected language of the audio.
    *   `title` (CharField, nullable): Title of the video/audio (e.g., YouTube video title).
    *   `transcription_text` (TextField, nullable): The full transcribed text.
    *   `include_timestamps` (BooleanField): Whether timestamps were requested/included.
    *   `duration_seconds` (IntegerField, nullable): Duration of the audio/video.
    *   `file_size_mb` (FloatField, nullable): Size of the media file.
    *   `processing_time_seconds` (FloatField, nullable): Time taken for transcription.
    *   `error_message` (TextField, nullable): Stores any error messages if the task failed.
    *   `retry_count` (IntegerField): Number of times a failed transcription has been retried.
    *   `created_at`, `updated_at`, `completed_at` (DateTimeField): Timestamps for tracking.
    *   **Relationships:** Has a one-to-many relationship with `TranscriptionSegment` and a one-to-many relationship with `ContentGeneration` (a transcription can lead to multiple content generation requests).
*   **`TranscriptionSegment`**: Stores individual segments of a transcription, particularly for large files.
    *   `transcription` (ForeignKey to `Transcription`): Links back to the parent transcription.
    *   `segment_number` (IntegerField): Order of the segment.
    *   `start_time`, `end_time` (FloatField): Start and end times of the segment in seconds.
    *   `text` (TextField): Transcribed text of the segment.
    *   `confidence` (FloatField, nullable): Confidence score of the segment's transcription.

### `apps.content_generation.models`

*   **`ContentGeneration`**: Represents a request to generate content (titles, description, chapters) for a specific transcription.
    *   `id` (UUID, Primary Key): Unique identifier for the content generation request.
    *   `user` (ForeignKey to `settings.AUTH_USER_MODEL`, nullable): The user who requested the content generation.
    *   `transcription` (ForeignKey to `transcriptions.Transcription`): The transcription used as input.
    *   `content_type` (CharField): The type of content requested (titles, description, chapters, complete package).
    *   `use_markdown` (BooleanField): Whether the generated content should use Markdown formatting.
    *   `title_types` (JSONField, nullable): List of specific title types requested (e.g., ['clickbait', 'seo']).
    *   `description_type` (CharField, nullable): The specific type of description requested (e.g., 'analÃ­tica').
    *   `max_chapters` (IntegerField, nullable): Maximum number of chapters to generate.
    *   `status` (CharField): Current status of the content generation (pending, processing, completed, failed).
    *   `language_detected` (CharField, nullable): Language for content generation (usually from the transcription).
    *   `generated_content` (TextField, nullable): Stores the generated content directly if it's a single block (e.g., a full description). For titles and chapters, this might be less used as they are stored in related models.
    *   `error_message` (TextField, nullable): Stores errors if generation failed.
    *   `created_at`, `updated_at`, `completed_at` (DateTimeField): Timestamps.
    *   **Relationships:** Has one-to-many relationships with `GeneratedTitle` and `GeneratedChapter`.
*   **`GeneratedTitle`**: Stores an individual generated title.
    *   `content_generation` (ForeignKey to `ContentGeneration`): Links to the parent generation request.
    *   `title_type` (CharField): The style/type of the generated title (e.g., 'viral', 'seo').
    *   `title_text` (CharField): The actual generated title string.
    *   `justification` (TextField, nullable): AI-generated explanation of why the title is effective.
    *   `keywords` (JSONField, nullable): List of keywords used/focused on in the title.
*   **`GeneratedChapter`**: Stores an individual generated video chapter.
    *   `content_generation` (ForeignKey to `ContentGeneration`): Links to the parent generation request.
    *   `chapter_number` (IntegerField): Sequential number of the chapter.
    *   `timestamp` (CharField): Timestamp of the chapter (e.g., "HH:MM:SS").
    *   `title` (CharField): The generated title for the chapter.
    *   `description` (TextField, nullable): Optional brief description for the chapter.

### `apps.users.models`

*   While not explicitly detailed in the provided file listing for `models.py`, this app would contain the User model (either Django's default `auth.User` or a custom model inheriting from `AbstractUser`). This model would store user credentials, email, plan status (Free/Premium), and any other user-specific information. 

## 7. Core Workflows and API Interactions

The application revolves around three primary, interconnected workflows: Transcription of Uploaded Media, AI Content Generation, and Complete Package Generation.

### Workflow 1: Transcription of Uploaded Media

1.  **Initiation (Frontend -> Backend API):**
    *   User uploads an audio/video file via the Vue.js frontend.
    *   Frontend makes a POST request to an endpoint like `/api/transcriptions/create/` (handled by `TranscriptionCreateView`).
    *   The request includes the file itself, `source_type` (e.g., 'audio_upload', 'video_upload'), and options like `include_timestamps`.
2.  **Object Creation & Task Queuing (Backend):**
    *   `TranscriptionCreateSerializer` validates the input.
    *   A `Transcription` object is created in the database with `status='pending'`. The user is associated if authenticated.
    *   `perform_create` method in `TranscriptionCreateView` then dispatches an asynchronous Celery task (`process_audio_transcription`) to handle the actual transcription.
3.  **Asynchronous Processing (Celery Worker):**
    *   The Celery worker picks up the task and calls `AudioTranscriptionService.process_transcription()`.
    *   The service extracts audio (if video), validates file size, and sends the audio to the Groq Whisper API.
    *   Results (transcription text, language detection, timestamps) are stored back in the `Transcription` object.
    *   Status is updated to `'completed'` or `'failed'` based on the outcome.
4.  **Frontend Polling/Updates:**
    *   The frontend polls the transcription status and updates the UI accordingly.

### Workflow 2: AI Content Generation (from Uploaded Media Transcriptions)

1.  **Initiation (Frontend -> Backend API):**
    *   User selects a completed `Transcription` (which originated from an uploaded file) from their list.
    *   User configures generation options in the UI:
        *   Selects output format (Plain Text/Markdown).
        *   Checks which content to generate (Titles, Description, Chapters).
        *   If Description is checked, selects a "Tipo de descriÃ§Ã£o" (e.g., 'analÃ­tica').
        *   If Chapters is checked, adjusts the "NÃºmero de capÃ­tulos" slider.
    *   Frontend makes a POST request to `/api/content-generation/create/` (handled by `ContentGenerationCreateView`).
    *   The request includes `transcription_id`, and the chosen options: `use_markdown`, selected `content_type`(s) (or a general flag if 'complete' package), `description_type`, `max_chapters`.
2.  **Object Creation & Task Queuing (Backend):**
    *   `ContentGenerationCreateSerializer` validates the input.
    *   A `ContentGeneration` object is created in the database with `status='pending'`.
    *   `create` method in `ContentGenerationCreateView` then dispatches an asynchronous Celery task (`process_content_generation`) to handle the actual AI generation.
3.  **Asynchronous Processing (Celery Worker):**
    *   The Celery worker picks up the task and calls `ContentGenerationService.process_content_generation()`.
    *   The service detects the language of the transcription (if not already detected).
    *   Based on the `content_type` and user options, it calls the appropriate generation methods:
        *   `generate_titles()` for titles with specified types and formatting.
        *   `generate_description()` for descriptions with specified style and formatting.
        *   `generate_chapters()` for chapters with specified count and formatting.
    *   Results are stored in the `ContentGeneration.generated_content` field.
    *   Status is updated to `'completed'` or `'failed'` based on the outcome.
4.  **Frontend Polling/Updates:**
    *   The frontend polls the content generation status and displays the results when completed.

### Workflow 3: Complete Package Generation

1.  **Initiation (Frontend -> Backend API):**
    *   User selects a completed `Transcription` from their list.
    *   User configures the complete package options in the dedicated UI section:
        *   **Content Selection:** Checkboxes for "Gerar TÃ­tulos", "Gerar DescriÃ§Ã£o", "Gerar CapÃ­tulos".
        *   **Output Format:** Radio buttons for "Texto simples" vs "Markdown".
        *   **Description Type:** Dropdown with options (analÃ­tica, curiosidade, hashtags, etc.) - only visible if description is selected.
        *   **Number of Chapters:** Slider from 3-20 chapters - only visible if chapters is selected.
    *   Frontend makes a POST request to `/api/content-generation/create/` with `content_type: 'complete'`.
    *   The payload includes only the options for selected content types (e.g., if only titles and description are checked, `title_types` and `description_type` are included, but `max_chapters` is omitted).
2.  **Object Creation & Task Queuing (Backend):**
    *   `ContentGenerationCreateSerializer` validates the input and creates a `ContentGeneration` object with `content_type='complete'`.
    *   The Celery task `process_content_generation` is dispatched.
3.  **Asynchronous Processing (Celery Worker):**
    *   `ContentGenerationService.process_content_generation()` detects that `content_type='complete'`.
    *   It analyzes which options were provided to determine what to generate:
        *   If `title_types` is provided and not empty â†’ generate titles.
        *   If `description_type` is provided â†’ generate description.
        *   If `max_chapters` is provided and > 0 â†’ generate chapters.
    *   Each selected content type is generated using the same methods as individual generation.
    *   All results are combined into a single `generated_content` field with appropriate formatting.
4.  **Frontend Display:**
    *   The complete package result is displayed as a single content item with the "ðŸ“¦ Pacote Completo" icon.
    *   Users can copy the entire generated content or view it with proper formatting (Markdown rendering if selected).

### Other Key API Endpoints (Relevant to the Focused Scope):

*   **User Management (Assumed, within `apps.users`):
    *   Login, Register, Profile management (JWT based).
*   **Statistics:**
    *   `/api/transcriptions/stats/` (`user_transcription_stats_view`): Counts of transcriptions (from uploads) by status.
    *   `/api/content-generation/stats/` (`user_content_generation_stats_view`): Counts of content generations (from uploaded media transcriptions) by status.
*   **Utility:**
    *   `/api/content-generation/available-transcriptions/` (`available_transcriptions_view`): Lists completed transcriptions (from uploads) ready for content generation.

## 8. External Service Integrations

The application, in its focused scope, relies on:

*   **Google Generative AI (e.g., Gemini models):**
    *   **Purpose:** Engine for generating titles, descriptions, chapters based on transcriptions from uploaded files.
    *   **Integration:** The `ContentGenerationService` in the backend constructs specific prompts based on user requests and transcription content, then sends these to the Google AI API. Results are parsed and stored.
    *   **Configuration:** Requires a `GOOGLE_API_KEY` environment variable.
*   **Groq Whisper API:**
    *   **Purpose:** Provides fast and accurate audio-to-text transcription for user-uploaded files.
    *   **Integration:** The `TranscriptionService` (specifically methods like `transcribe_audio_groq`) in the backend sends audio data (either from YouTube or uploaded files) to the Groq API and retrieves the transcribed text and timestamps.
    *   **Configuration:** Requires a `GROQ_API_KEY` environment variable.

## 9. Prompts and AI Logic (`escopo-do-projeto.md` & Implied Logic)

The `escopo-do-projeto.md` file is crucial as it details many of the specific prompts and foundational logic used to instruct the AI. The application extends this by incorporating direct user choices into the final prompts sent to the AI:

*   **User-Driven Prompt Modification:**
    *   **Formatting Choice:** The user's selection of "Texto simples" or "Markdown" directly influences the part of the prompt that tells the AI how to structure its output (e.g., `use_markdown` parameter in `ContentGenerationService` methods).
    *   **Description Style:** The chosen "Tipo de descriÃ§Ã£o" (e.g., 'analÃ­tica', 'curiosidade') is used by `ContentGenerationService.generate_description()` to select or modify the prompt to match that specific style, ensuring the AI adopts the correct tone and focus.
    *   **Chapter Count:** The user-defined "NÃºmero de capÃ­tulos" is passed to `ContentGenerationService.generate_chapters()` and is used in the prompt to instruct the AI on how many distinct chapters to create from the transcription.
*   **Base Prompts:** General instructions given to the AI about its role (e.g., "VocÃª Ã© um especialista avanÃ§ado em YouTube SEO...") likely remain foundational, with user choices adding further specialization.
*   **Specific Prompts per Content Type:** While `escopo-do-projeto.md` details many internal title and description types, the user's high-level selections (generate titles/description/chapters) and specific choices (like description type) refine which prompts or prompt variations are used.
*   **Language Consideration:** Prompts explicitly instruct the AI to generate content in the detected language of the source transcription, and this is maintained regardless of other user choices.
*   **Premium vs. Free Tier Logic:** User plan differences (e.g., number of title variations) are also factored into the generation logic, potentially enabling more options or different prompt paths for premium users.

This combination of detailed base prompts (from `escopo-do-projeto.md`) and dynamic modification based on user interface selections (like formatting, description type, chapter count) allows for flexible and tailored AI content generation.

## 10. Deployment and Configuration

*   **Containerization:** The application is designed for Docker deployment, with `Dockerfile` present in both `backend` and `frontend` directories, and a `docker-compose.yml` for orchestrating the services (backend, frontend, PostgreSQL, Redis).
*   **Deployment Platform:** Coolify is mentioned as the target deployment platform (`coolify-simple.yml`, `DOCKER.md`, `README.md`).
*   **Environment Variables:** Critical configurations, especially API keys (`GOOGLE_API_KEY`, `GROQ_API_KEY`), database credentials (`DB_PASSWORD`), and Django's `SECRET_KEY`, are managed through environment variables (as seen in `.env.example` and deployment instructions).
*   **Web Server (Frontend):** An `nginx.conf` file in the `frontend` directory suggests Nginx is used to serve the static Vue.js application and likely proxy API requests to the backend Django application in a production environment.

## 11. Potential Areas for Future Development/Consideration (Inferred)

*   **WebSockets:** For real-time status updates on transcription/generation progress instead of polling.
*   **Advanced User Roles/Permissions:** Beyond Free/Premium, for team or agency use.
*   **Direct YouTube Integration:** Posting generated content directly to a user's YouTube channel (would require YouTube API write permissions and OAuth).
*   **Analytics on Generated Content Performance:** Tracking how AI-suggested titles/descriptions perform on YouTube.
*   **A/B Testing Framework:** Allowing users to test different AI-generated titles/thumbnails.
*   **Image/Thumbnail Generation:** Extending AI capabilities to suggest or generate video thumbnails.
*   **More Sophisticated Niche Detection:** Beyond basic keywords, to better tailor AI prompts.

## 12. Summary and Conclusion

"Your Social Media" is a sophisticated, full-stack web application meticulously designed to empower YouTube content creators. With the current focus primarily on transcribing user-uploaded audio/video files and subsequently generating AI-driven content, it leverages modern technologies across its frontend (Vue.js 3, TypeScript, Pinia, Tailwind CSS) and backend (Django REST Framework, Python, PostgreSQL, Celery, Redis). It integrates powerful third-party AI services (Google Generative AI for content creation, Groq Whisper API for transcription) for its core functionalities.

The application's primary value proposition, within this focused scope, lies in its ability to automate and enhance the workflow of taking user-provided media, transcribing it accurately, and then creating a suite of optimized YouTube metadata (titles, descriptions, chapters) from that transcription. By offering a wide variety of AI-generated content styles and supporting multiple languages, it aims to help creators improve their SEO, increase viewer engagement, and streamline their content production workflow based on their own media files.

The detailed prompt engineering outlined in `escopo-do-projeto.md` remains a significant asset, indicating a deep understanding of the YouTube ecosystem and AI content generation from transcribed text. The asynchronous architecture ensures scalability and a good user experience for the transcription and generation processes. The planned Free/Premium tiers provide a clear monetization strategy around these core features.

Overall, "Your Social Media," even with a narrowed focus on uploaded media, appears as a well-architected and feature-rich platform dedicated to solving specific pain points for YouTube creators through intelligent automation of transcription and content optimization.

## 13. Recent Implementation: Complete Package Feature

### Overview
The Complete Package feature was implemented to address the need for users to generate all content types (titles, descriptions, chapters) in a single, unified workflow with customizable options. This feature provides a more streamlined experience compared to generating each content type individually.

### Frontend Implementation
**Location:** `frontend/src/views/ContentGenerationView.vue`

**New UI Components:**
- **Complete Package Section:** A dedicated section below the individual content generation cards
- **Content Selection Checkboxes:** Allow users to choose which content types to generate
- **Output Format Radio Buttons:** Choice between plain text and Markdown formatting
- **Dynamic Options:** Description type dropdown and chapter count slider appear only when relevant content types are selected
- **Unified Generation Button:** Single button to initiate the complete package generation

**Key Features:**
- **Responsive Design:** Grid layout that adapts to different screen sizes
- **Conditional Visibility:** Options only appear when relevant content types are selected
- **Real-time Validation:** Button is disabled when no content types are selected
- **Visual Distinction:** Gradient styling to differentiate from individual generation buttons

### Backend Implementation
**Location:** `backend/apps/content_generation/services.py`

**Enhanced Logic:**
- **Smart Content Detection:** The system analyzes which options are provided to determine what content to generate
- **Flexible Generation:** Only generates content for which specific options are provided
- **Debug Logging:** Added comprehensive logging to track the complete package generation process
- **Unified Output:** All generated content is combined into a single response with proper formatting

**Processing Flow:**
1. **Option Analysis:** Checks which content options are provided in the request
2. **Selective Generation:** Only calls generation methods for selected content types
3. **Content Combination:** Merges all generated content into a unified output
4. **Status Management:** Tracks the overall success/failure of the complete package

### User Experience Improvements
- **Single-Click Generation:** Users can generate all desired content types with one action
- **Customizable Output:** Full control over formatting and content selection
- **Visual Feedback:** Clear indication of what content will be generated
- **Consistent Interface:** Maintains the same polling and status update mechanisms as individual generation

### Technical Benefits
- **Code Reuse:** Leverages existing generation methods for individual content types
- **Maintainability:** Changes to individual generation logic automatically apply to complete packages
- **Scalability:** Easy to add new content types to the complete package workflow
- **Error Handling:** Robust error handling with detailed logging for troubleshooting

This implementation successfully addresses the user requirement for a unified content generation experience while maintaining the flexibility and customization options that make the platform valuable for YouTube content creators. 